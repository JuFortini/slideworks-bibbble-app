## Escolha do Framework

Eu escolhi trabalhar com o framework Nextjs pelo seu dinamismo. Apesar de na api conter apenas 10 itens, como é um app de biblioteca, numa possível evolução disso, haveriam muitos livros e eles não mudariam constantemente no app, ou seja, não seria um app com muito dinamismo, portanto o uso do SSG no Nextjs torna possível a renderização desses dados de forma a não exigir muito do servidor, ainda mais no caso de muitos acessos simultâneos. <br />
Escolhi trabalhar com a biblioteca ChakraUI para estilização porque gosto e ela torna muito mais tranquila a formatação da responsividade.

## Getting Started

Como eu vou trabalhar com Typescript, nas configurações iniciais, eu o instalei e troquei as extensões dos arquivos, além de criar a pasta src e incluir a pasta pages dentro dela. Troquei todo o conteúdo da Home por um <strong>Hello World!</strong> e rodei o app para começar a visualizar as mudanças.
- Problema: o arquivo tsconfig.json apresentou um erro que eu nunca tinha experimentado em '"resolveJsonModule": true', onde dizia que essa opção não podia ser especificada sem uma estratégia de resolução do módulo como 'node'. Eu segui o link da descrição do erro https://www.typescriptlang.org/tsconfig#resolveJsonModule, mas era uma página que descrevia a função do resolveJsonModule e não a origem do erro em si. Então, usando como base um app anterior que eu desenvolvi e o que descrição pedia, eu especifiquei a estratégia de resolução como 'node', incluindo uma linha de código acima como '"moduleResolution": "node"' e o problema foi resolvido.

Em seguida, eu identifiquei no Figma as fontes que foram usadas (Roboto e Inter) e as selecionei no Google Fonts. Criei o arquivo '_document.tsx' para poder atualizar o 'Head' com as novas fontes e adicionar um favicon para ficar mais legal a apresentação. <br />
O próximo passo foi instalar o ChakraUI para começar a estilização inicial da página. Novamente no Figma, eu identifiquei as cores mais usadas e fontes, para atualizar os o tema pré-definido do ChakraUI. Atualizei o app com o Provider do ChakraUI e atualizei as definições importando o novo tema. <br />

## Header

Começando a desenvolver o Header, eu criei uma pasta pensando em separar a Navbar como um segundo componente dentro do Header. Determinei a altura do Header em um display block, fiz o download da logo como .svg e comecei por ela. Eu costumo colocar backgrounds coloridos para me ajudarem a perceber os limites de cada item, dessa forma, eu perebi que seria melhor criar uma div com display flex com as margens de acordo com o tamanho à esquerda da logo e depois organizar todos os componentes dentro dela. <br />
Próximo passo foi criar a Navbar que à princípio eu criei os itens com Link importado do next mesmo, mas ainda vou avaliar outras opções. Além disso, eu instalei o react-icons, que eu estou mais acostumada, para usar no ícone da lupa. <br />
Agora sim, eu nomeei os itens corretamente na Navbar e completei o que seriam as referências para as páginas. Apesar de ser uma página estática, eu quis criar de forma automatizada o formato negrito para as páginas ativas. Para isso eu pensei em criar cada item da Navbar como um componente e esse seria testado se é o componente ativo ou não, como eu já havia feito antes em um app anterior. Então, eu criei então o componente "NavLink.tsx" e nele uma função que verificaria se a rota da url é a mesma passada pelo href, se sim, o item seria mostrado em negrito. Então, eu substituí os itens que a princípio eu tinha criado como Link do next. O app que eu estava utilizando como base era mais complexo do que precisava, então, com o auxílio da própria documentação do next https://nextjs.org/docs/api-reference/next/router, eu tornei um pouco mais simples, de acordo com demanda para esse app. <br />
Nesta etapa, eu criei a página 'About' para testar apenas com o Header e um título. Desta forma, eu percebi que seria mais prático tornar o Divider como parte do Header, visto que antes eu havia deixado como um componente separado.
- Observação: deixei a página 'About' que eu usei para teste ativa, caso queiram testar.

## Footer

Determinei o componente Footer como uma div com display block e dentro eu criei uma outra div com display flex direcionando como coluna e com uma margem de acordo com o layout do Figma. Nela eu imaginei 3 caixas: a logo do LibSlide; o Divider; e uma caixa abaixo onde teriam duas caixas dentro, uma com o termos e políticas e outra com as redes sociais que eu poderia alinhar usando um display flex. <br />
Ao colocar o componente Divider, eu percebi que a altura de 1 pixel que eu estava determinado era inútil no Chakra, que por padrão já era 1px e se eu precisasse aumentar deveria mexer na borda e não na altura. Na documentação não está muito especificada essa parte, então tive que optar por tentativa e erro e usar o auxílio do inspect no navegador para ver o que estava sendo considerado no elemento. Então eu fiz essa alteração para o Divider do Header também. <br />
Percebi uma nova fonte no Footer, DM Sans, então eu retornei ao Google Fonts e atualizei as fontes. <br />

## Main

Para o conteúdo principal, eu criei os cards dos livros como um componente e quando eu der um GET no conteúdo da api, seja criado um card para cada conteúdo. Eu fiz isso recentemente em um projeto, então estava mais ou menos fresco na minha cabeça. <br />
Eu dispus os cards em uma grid, com um espaçamento vertical fixo e horizontal variável de acordo com o tamanho da página. Determinei uma largura máxima para os cards, de forma que de acordo com a largura da página eles vão se reajustar sem perder a qualidade da sua apresentação. <br />
- Problema: eu pensei em fazer um template-columns com 4 colunas, mas seria algo fixo e nada responsivo, portanto eu tinha que fazer algo que se ajustasse. Para dispor os cards de forma responsiva, o ChakraUI na sua documentação https://chakra-ui.com/docs/components/simple-grid/usage, indica utilizar uma largura mínima para cada item do grid, dessa forma eles se rearranjam de acordo com a largura da página respeitando esse limite. Determinei então um tamanho mínimo, mas assim eles não ficavam com espaço igualmente distribuído entre os cards e eles ficavam dispostos como justificados à esquerda e eu queria mais como um 'space-between' e o mais óbvio, que era justificar os itens com um 'space-between' não funcionava. Tive bastante problema para ajustar isso, porque a documentação do ChakraUI não explica muito bem como usar o template-columns. Então olhando no inspect do navegador, eu percebi que a largura máxima que eu tinha preenchido era apresentada lá como um 'grid-template-columns: repeat(auto-fit, minmax(16rem, 1fr))', voltei na documentação e lá dizia que o Chakra fazia isso quando se determinava a largura mínima. Então eu pensei em mexer nos argumentos e determinar uma largura máxima também, ao invés de 1fr, porque ao botar 1fr, ele divide todo o espaço e ocupa toda a fração pertecente a ele, não deixando espaço vazio para o elemento se locomover. Determinei então a largura máxima igual à largura mínima porque assim ele não ocuparia nenhum espaço além do que ele precisava, e justifiquei com o 'space-between' pra ficar com espaçamento igual entre os cards.

Para fazer a busca dos dados da api, eu utilizei o axios por ser mais simples e intuitivo, me retornando já os dados em uma string. Eu fiz a busca desses dados dentro do getStaticProps e fiz um .map() no 'data' da resposta. Isso me gerou um erro no navegador e no terminal dizendo que .map() não era uma função. Então, eu dei um console.log para ver como eles estava sendo retornados, nisso eu percebi na resposta que eles estavam dentro de 'data.data', então eu fiz um .map() agora em 'data.data' e os itens do array de livros foram retornados e eu retornei eles numa constante como props para a Home.
- Observação: De algumas aulas que assisti, foi extremamente indicado já retornar os dados formatados na props do getStaticProps, então eu formatei os dados que precisava em um objeto com o id, o título, o autor, a descrição, a imagem, o gênero e a data de publicação. Quanto à data de publicação, ela estava no formato 'aaaa-MM-dd' e eu usei a biblioteca date-fns para formatar. Para isso, eu usei a ferramenta parse para formatar de 'aaaa-mm-dd' para (aaaa, MM, dd) e depois a ferramenta format para formatar de (aaaa, MM, dd) para o formato final 'dd LLL. aaaa', sendo 'LLL' o mês por extenso com 3 caracteres, que foi o formato pedido.

Então, com os dados retornados e já formatados, eu fiz um .map() dentro da Home, retornando um componente bookCards para cada livro. Como eles estavam com o layout funcional, já se arranjaram conforme o tamanho da página com os espaçamentos definidos.
- Problema: a descrição ultrapassa o limite e empurra todo o conteúdo que está abaixo dela para fora do card. Eu poderia resolver isso aumentando o tamanho do card, mas achei que ficaria desproporcional, então optei por diminuir a descrição, limitando ela por quantidade de caracteres usando o .substring pegando do caractere 0 até o 50 e colocar um botão com '...mais' para exibir o restante da descrição. Ainda não decidi como, estou pensando em um Popover (que o usuário clica neste botão e abre uma caixa de interação), um Tooltip (que mostra uma apresentação quando o usuário interage) ou um Modal com todo o card expandido.

Por fim, decidi optar por um Popover, deixei essa parte para o final e foi uma das últimas coisas que eu fiz. E depois disso, o layout para mobile apresentou um espaçamento à direita que não havia antes. Eu demoraria muito tempo para imaginar o motivo disto, mas como mudou logo depois da implementação deste Popover, eu sondei o problema focando nele. Determinei uma largura para o conteúdo o Popover e isso resolveu o problema.

## Responsividade

Pra essa parte, eu fiz o básico de diminuir margens e paddings de acordo com a largura da página. Com a ajuda do ChakraUI, eu posso colocar isso tudo em um array sendo o primeiro o array[0] o valor para a página no seu menor tamanho, array[1] o valor para o tamanho um pouco maior da página e assim por diante, usando esses tamanhos como padrão https://chakra-ui.com/docs/styled-system/theme#breakpoints, eu segui dessa forma, como na documentação. <br />
No Footer, eu quebrei o direcionamento dos itens mais inferiores, ao invés de alinhado horizontalmente, ele quebraram para um direcionamento em forma de coluna para páginas pequenas. <br />
No Header, eu tive mais trabalho. Minha ideia, de cara, foi transformar o menu de navegação horizontal em um modal do tipo drawer que abre com um menu hambúrguer que só fica disponível na formatação para janelas pequenas. Então, com a ajuda de outro projeto que eu havia feito anteriormente e a documentação do ChakraUi https://chakra-ui.com/docs/components/drawer/usage#usage eu criei um drawer bem simples com um cabeçalho e um menu de navegação vertical com as mesmas propriedades do horizontal. Fiz isso em um context, visando o funcionamento no eventual progresso do desenvolvimento e, assim ele funcionaria em todo o app.
- Problema: O drawer não estava abrindo para janelas pequenas. Então eu expandi a possibilidade para abrir em janelas maiores e nessas ele funcionava. Fiquei algum tempo desvendando esse mistério e olhando o inspect do navegador para janela grande o ChakraUi criava uma div para este modal, mas na janela pequena essa div desaparecia. Eu mudei os breakpoints para tentar os limites do tamanho da página divesas vezes e não funcionou, destrinchei o antigo projeto que usava um Drawer parecido e tudo parecia estar certo (isso é codar, certo? Desistir nunca haha). Levantei, respirei, tomei um café com biscoitos (não bolachas, eu sei que são de SP rs) e voltei. Olhei o cógigo mais uma vez com calma e percebi que eu não estava renderizando o componente Navbar para janelas pequenas e estava usando ele no meu drawer que era para renderizar apenas em janelas pequenas. Então óbvio que não ia aparecer.

## Extra feature

Eu quis incluir um dark mode, espero que não se importem, acho legal e menos agressivo aos olhos. Desculpem se o design não ficou nas melhores cores. <br />
Para fazer o dark mode foi bem simples com o ChakraUI e não tive muito problema, ele fornece ferramentas bem práticas e a documentação é bem completa para esse aspecto, podem ver aqui https://chakra-ui.com/docs/styled-system/color-mode.

